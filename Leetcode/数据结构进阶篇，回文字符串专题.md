# 数据结构进阶篇，回文字符串专题

### 5. 最长回文子串

&emsp;&emsp;**题目**:

&emsp;&emsp;给你一个字符串 s，找到 s 中最长的回文子串。

&emsp;&emsp;**示例**：

&emsp;&emsp;输入：s = "babad"，输出："bab"。

&emsp;&emsp;**解题思路**：

&emsp;&emsp;首先，判断一个字符串是否为回文字符串，可以采用*双指针*的方式来处理，需要消耗* O(n) *的时间复杂度。

&emsp;&emsp;*如果使用首尾向中心扫描的策略，那么就需要 O(n^2) 的时间复杂度来确定子串，而更换为由中心向两边扫描的策略，则只需要 O(n) 的时间复杂度即可确定子串。*

&emsp;&emsp;*首尾向中心扫描的策略是基于子串确定的前提下，所以不需要考虑字符串的奇偶性。而中心扩展算法只有在识别到首尾字符不一致的情况，才能确定当前子串*，而对于奇数长度的字符串和偶数长度的字符串，它们的中心点是不一样的：

- 奇数长度字符串的中心点：Math.floor(len / 2)。
- 偶数长度字符串的中心点：len / 2 - 1 和 len / 2。

&emsp;&emsp;时间复杂度：*O(n^2)*，空间复杂度：*O(1)*。

```JavaScript
const longestPalindrome = (s) => {
    if (!s) {
        return ''
    }

    let start = 0;
    let end = 0;
    for (let i = 0; i < s.length; i++) {
        const odd = expandAroundCenter(s, i - 1, i + 1);
        const even = expandAroundCenter(s, i, i + 1);
        const len = Math.max(odd.len, even.len);
        if (len > end - start) {
            if (odd.len === len) {
                start = odd.left;
                end = odd.right;
            } else {
                start = even.left;
                end = even.right;
            }
        }
    }

    return s.substring(start, end + 1);
}

function expandAroundCenter (s, left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
        --left;
        ++right;
    }

    return {
        left: left + 1,
        right: right - 1,
        len: right - left - 1
    }
}
```