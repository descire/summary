# 数据结构进阶篇，回文字符串专题

### 5. 最长回文子串

&emsp;&emsp;**题目**:

&emsp;&emsp;给你一个字符串 s，找到 s 中最长的回文子串。

&emsp;&emsp;**示例**：

&emsp;&emsp;输入：s = "babad"，输出："bab"。

&emsp;&emsp;**解题思路**：

&emsp;&emsp;首先，判断一个字符串是否为回文字符串，可以采用*双指针*的方式来处理，需要消耗* O(n) *的时间复杂度。

&emsp;&emsp;*如果使用首尾向中心扫描的策略，那么就需要 O(n^2) 的时间复杂度来确定子串，而更换为由中心向两边扫描的策略，则只需要 O(n) 的时间复杂度即可确定子串。*

&emsp;&emsp;*首尾向中心扫描的策略是基于子串确定的前提下，所以不需要考虑字符串的奇偶性。而中心扩展算法只有在识别到首尾字符不一致的情况，才能确定当前子串*，而对于奇数长度的字符串和偶数长度的字符串，它们的中心点是不一样的：

- 奇数长度字符串的中心点：Math.floor(len / 2)。
- 偶数长度字符串的中心点：len / 2 - 1 和 len / 2。

&emsp;&emsp;时间复杂度：*O(n^2)*，空间复杂度：*O(1)*。

```JavaScript
const longestPalindrome = (s) => {
    if (!s) {
        return ''
    }

    let start = 0;
    let end = 0;
    for (let i = 0; i < s.length; i++) {
        const odd = expandAroundCenter(s, i - 1, i + 1);
        const even = expandAroundCenter(s, i, i + 1);
        const len = Math.max(odd.len, even.len);
        if (len > end - start) {
            if (odd.len === len) {
                start = odd.left;
                end = odd.right;
            } else {
                start = even.left;
                end = even.right;
            }
        }
    }

    return s.substring(start, end + 1);
}

function expandAroundCenter (s, left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
        --left;
        ++right;
    }

    return {
        left: left + 1,
        right: right - 1,
        len: right - left - 1
    }
}
```

### 131. 分割回文串

&emsp;&emsp;**题目**：

&emsp;&emsp;给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串 。返回 s 所有可能的分割方案。

&emsp;&emsp;**示例**：

&emsp;&emsp;输入：s = "aab"，输出：[["a","a","b"],["aa","b"]]。

&emsp;&emsp;**解题思路**：

&emsp;&emsp;*由于题目要求返回所有的分割方案，所以只能采用回溯的方式进行枚举。*

&emsp;&emsp;*由于本道题的第一个回文字符串的起点是固定的，所以只能采用首尾向中心扫描的算法来判断当前子串是否为回文字符串。*

&emsp;&emsp;时间复杂度：*O(n2^n)*，空间复杂度：*O(2^n)*。

```JavaScript
const partition = s => {
  const max = s.length
  const ans = []
  const path = []

  backtrack(s, 0, path, ans, max);
  return ans
}

function backtrack(str, position, path, ans, max) {
  if (position === max) {
    return ans.push([...path]);
  }

  for (let i = position; i < max; i++) {
    if (isPalindrome(str, position, i)) {
      path.push(str.substring(position, i + 1))
      backtrack(str, i + 1, path, ans, max);
      path.pop();
    } 
  }
}

function isPalindrome(str, start, end) {
  while (start < end) {
    if (str[start] === str[end]) {
      start++;
      end--;
    } else {
      return false;
    }
  }

  return true;
}
```