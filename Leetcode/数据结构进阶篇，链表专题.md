### 61. 旋转链表

&emsp;&emsp;**题目：**

&emsp;&emsp;给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入：head = [1,2,3,4,5], k = 2, 输出：[4,5,1,2,3].

&emsp;&emsp;**解题思路：**

&emsp;&emsp;*记链表的长度为 n，如果 k 大于等于 n 时，只需要向右移动 k % n 次即可，因为每 n 次移动，链表会恢复原状。*

&emsp;&emsp;由上图可知（链表题型画完图，能很清晰地梳理出节点之间的引用变换）：

- *遍历链表，获取到链表的长度，那么分割点即为 length - (k % length)，这里需要将前置节点的 next 设置为 null，所以分割点的位置需要向前移动一位*
- *遍历到链表的尾节点，将其指向旧链表的头节点。*

&emsp;&emsp;一定要舍得使用临时变量来管理链表节点的引用。

&emsp;&emsp;时间复杂度：*O(n)*，空间复杂度：*O(1)*。

```JavaScript
const rotateRight = (head, k) => {

  if (!head || !head.next) {
    return head;
  }

  let length = 0;
  let currentHead = head;
  while (currentHead) {
    length++;
    currentHead = currentHead.next;
  }

  let index = length - (k % length) - 1;

  currentHead = head;
  while (index) {
    currentHead = currentHead.next;
    index--;
  }

  let lastHead = currentHead;
  while (lastHead.next) {
    lastHead = lastHead.next;
  }

  lastHead.next = head;
  const ans = currentHead.next;
  currentHead.next = null;

  return ans;
}
```

### 92. 反转链表 II

&emsp;&emsp;**题目：**

&emsp;&emsp;给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入：head = [1,2,3,4,5], left = 2, right = 4, 输出：[1,4,3,2,5].

&emsp;&emsp;**第一种解题思路：先将需要翻转的区间剥离成单独的链表，并且保存该链表的前驱节点和后继节点，然后对其进行翻转操作，最后将前驱节点和后继节点关联上。**

&emsp;&emsp;时间复杂度：*O(n)*，空间复杂度：*O(1)*。

```JavaScript
const reverseBetween = (head, m, n) => {
  const dummyHead = new ListNode(null);
  dummyHead.next = head;

  let preHead = dummyHead;

  for (let i = 0; i < m - 1; i++) {
    preHead = preHead.next;
  }

  let rightHead = preHead;
  for (let i = 0; i < n - m + 1; i++) {
    rightHead = rightHead.next;
  }

  let leftHead = preHead.next;
  let sufHead = rightHead.next;

  preHead.next = null;
  rightHead.next = null;
  
  reverseLinkedList(leftHead);

  preHead.next = rightHead;
  leftHead.next = sufHead;

  return dummyHead.next;
}

function reverseLinkedList(head) {
  let pre = null;
  let current = head;

  while (current) {
    const next = current.next;
    current.next = pre;
    pre = current;
    current = next;
  }
}
```

&emsp;&emsp;**第二种解题思路：**

&emsp;&emsp;时间复杂度：*O(n)*，空间复杂度：*O(1)*。

```JavaScript
const reverseBetween = (head, m, n) => {
    const dummyHead = new ListNode(null);
    dummyHead.next = head;

    let preHead = dummyHead;
    for (let i = 0; i < m - 1; i++) {
        preHead = preHead.next;
    }

    let current = preHead.next;
    let next = null;

    for (let i = 0; i < n - m; i++) {
        next = current.next;
        current.next = next.next;
        next.next = preHead.next;
        preHead.next = next;
    }

    return dummyHead.next;
}
```

### 写在最后

&emsp;&emsp;**感谢您能耐心地读到这里，如果本文对您有帮助，欢迎点赞、分享、或者关注下方的公众号哟。**

&emsp;&emsp;相关链接：

- https://leetcode-cn.com/problems/rotate-list/
- https://leetcode-cn.com/problems/reverse-linked-list-ii/