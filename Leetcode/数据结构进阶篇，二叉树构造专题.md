### 105. 从前序与中序遍历序列构造二叉树

&emsp;&emsp;**题目：**

&emsp;&emsp;给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]，输出: [3,9,20,null,null,15,7]。

&emsp;&emsp;**解题思路：**

 &emsp;&emsp;解决这类题目的核心点，需要理解二叉树的几种遍历序列：

  - 前序遍历 根 - 左 - 右
  - 中序遍历 左 - 根 - 右
  - 后序遍历 左 - 右 - 根

&emsp;&emsp;然后就需要从一个序列中找到根节点，通过在另一个序列中查找该根节点，从而获取到左右子树的遍历序列。

&emsp;&emsp;举个例子：

```s
  前序遍历序列：[3,9,20,15,7]
  中序遍历序列：[9,3,15,20,7]
```

&emsp;&emsp;首先从前序遍历中，很容易可以找到当前子树的根节点为3，从中序遍历序列中，又可以知道3的左边为左子树的中序遍历序列，右边为右子树的中序遍历序列，那么通过根节点在中序遍历序列中的下标进行分割，可以得到左右子树的遍历序列。

```s
  1、左子树
  前序遍历序列： [9]
  中序遍历序列： [9]

  2、右子树
  前序遍历序列： [20, 15, 7]
  中序遍历序列： [15, 20, 7]
```

&emsp;&emsp;依此类推，即可递归地构造出二叉树。

&emsp;&emsp;时间复杂度：O(n)，空间复杂度：O(n)。

```JavaScript
const buildTree = (preorder, inorder) => {
  if (preorder.length === 0) {
    return null;
  }

  const rootValue = preorder.shift();

  const root = new TreeNode(rootValue);

  const index = inorder.indexOf(rootValue);

  root.left = buildTree(preorder.slice(0, index), inorder.slice(0, index));
  root.right = buildTree(preorder.slice(index), inorder.slice(index + 1));

  return root;
}
```

### 106. 从中序与后序遍历序列构造二叉树

&emsp;&emsp;**题目：**

&emsp;&emsp;给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]，输出：[3,9,20,null,null,15,7]。

&emsp;&emsp;

&emsp;&emsp;时间复杂度：O(n)，空间复杂度：O(n)。

```JavaScript
const buildTree = (inorder, postorder) => {
  if (inorder.length === 0) {
    return null
  }

  const rootValue = postorder.pop()
  const root = new TreeNode(rootValue)
  const index = inorder.indexOf(rootValue)
  root.left = buildTree(inorder.slice(0, index), postorder.slice(0, index))
  root.right = buildTree(inorder.slice(index + 1), postorder.slice(index))
  return root
}
```

### 889. 根据前序和后序遍历构造二叉树

&emsp;&emsp;**题目：**

&emsp;&emsp;给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。

&emsp;&emsp;如果存在多个答案，您可以返回其中 任何 一个。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]，输出：[1,2,3,4,5,6,7]。

&emsp;&emsp;时间复杂度：O(n)，空间复杂度：O(n)。

```JavaScript
const constructFromPrePost = (pre, post) => {
  if (pre.length === 0) {
    return null
  }
  // 拿出根节点
  const rootValue = pre.shift()
  post.pop()

  const root = new TreeNode(rootValue)

  if (pre.length > 0) {
    // 左子树的根节点
    const l = pre[0]
    const lIndex = post.indexOf(l)

    root.left = constructFromPrePost(pre.slice(0, lIndex + 1), post.slice(0, lIndex + 1))
    root.right = constructFromPrePost(pre.slice(lIndex + 1), post.slice(lIndex + 1))
  }
  return root
}
```

### 1008. 前序遍历构造二叉搜索树

&emsp;&emsp;**题型：**

&emsp;&emsp;给定一个整数数组，它表示BST(即 二叉搜索树 )的 先序遍历 ，构造树并返回其根。

&emsp;&emsp;保证 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入：preorder = [8,5,1,7,10,12]，输出：[8,5,10,1,7,null,12]。

&emsp;&emsp;**第一种解题思路：**

&emsp;&emsp;**第二种解题思路：**

```JavaScript
```


### 写在最后

&emsp;&emsp;**感谢您能耐心地读到这里，如果本文对您有帮助，欢迎点赞、分享、或者关注下方的公众号哟。**

&emsp;&emsp;相关链接：

- https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
- https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
- https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/
- https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/