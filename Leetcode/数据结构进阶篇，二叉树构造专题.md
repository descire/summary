### 105. 从前序与中序遍历序列构造二叉树

&emsp;&emsp;**题目：**

&emsp;&emsp;给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]，输出: [3,9,20,null,null,15,7]。

&emsp;&emsp;**解题思路：**

&emsp;&emsp;*由于二叉树是递归定义的，所以只需要寻找根节点、左子树以及右子树之间的关系，即可构造出二叉树*。

&emsp;&emsp;*参照上述图解，通过前序序列可以轻松地找到当前子树的根节点，然后通过中序序列依据该根节点分割其左右子树，所以这里有一个重要的隐藏条件就是二叉树中的元素值不能重复！*

&emsp;&emsp;依此类推，即可得到结果

&emsp;&emsp;时间复杂度：O(n^2)，空间复杂度：O(n)。

```JavaScript
const buildTree = (preorder, inorder) => {
  // 递归中止条件
  if (preorder.length === 0) {
    return null;
  }

  const rootElement = preorder[0];
  const root = new TreeNode(rootElement);

  const rootElementIndex = inorder.indexOf(rootElement);

  root.left = buildTree(preorder.slice(1, rootElementIndex + 1), inorder.slice(0, rootElementIndex));
  root.right = buildTree(preorder.slice(rootElementIndex + 1), inorder.slice(rootElementIndex + 1));

  return root;
}
```

&emsp;&emsp;

### 106. 从中序与后序遍历序列构造二叉树

&emsp;&emsp;**题目：**

&emsp;&emsp;给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]，输出：[3,9,20,null,null,15,7]。

&emsp;&emsp;

&emsp;&emsp;时间复杂度：O(n)，空间复杂度：O(n)。

```JavaScript
const buildTree = (inorder, postorder) => {
  if (inorder.length === 0) {
    return null
  }

  const rootValue = postorder.pop()
  const root = new TreeNode(rootValue)
  const index = inorder.indexOf(rootValue)
  root.left = buildTree(inorder.slice(0, index), postorder.slice(0, index))
  root.right = buildTree(inorder.slice(index + 1), postorder.slice(index))
  return root
}
```

### 889. 根据前序和后序遍历构造二叉树

&emsp;&emsp;**题目：**

&emsp;&emsp;给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。

&emsp;&emsp;如果存在多个答案，您可以返回其中 任何 一个。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]，输出：[1,2,3,4,5,6,7]。

&emsp;&emsp;时间复杂度：O(n)，空间复杂度：O(n)。

```JavaScript
const constructFromPrePost = (pre, post) => {
  if (pre.length === 0) {
    return null
  }
  // 拿出根节点
  const rootValue = pre.shift()
  post.pop()

  const root = new TreeNode(rootValue)

  if (pre.length > 0) {
    // 左子树的根节点
    const l = pre[0]
    const lIndex = post.indexOf(l)

    root.left = constructFromPrePost(pre.slice(0, lIndex + 1), post.slice(0, lIndex + 1))
    root.right = constructFromPrePost(pre.slice(lIndex + 1), post.slice(lIndex + 1))
  }
  return root
}
```

### 1008. 前序遍历构造二叉搜索树

&emsp;&emsp;**题型：**

&emsp;&emsp;给定一个整数数组，它表示BST(即 二叉搜索树 )的 先序遍历 ，构造树并返回其根。

&emsp;&emsp;保证 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。

&emsp;&emsp;**示例：**

&emsp;&emsp;输入：preorder = [8,5,1,7,10,12]，输出：[8,5,10,1,7,null,12]。

&emsp;&emsp;**第一种解题思路：**

&emsp;&emsp;**第二种解题思路：**

```JavaScript
```


### 写在最后

&emsp;&emsp;**感谢您能耐心地读到这里，如果本文对您有帮助，欢迎点赞、分享、或者关注下方的公众号哟。**

&emsp;&emsp;相关链接：

- https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
- https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
- https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/
- https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/