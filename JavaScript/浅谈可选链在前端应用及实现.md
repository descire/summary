# 浅谈可选链在前端应用及实现

### 一、前言

&emsp;&emsp;开发过程中，避免不了操作复杂的嵌套对象，而对于这种场景通常会遇到两个痛点：

- 操作嵌套对象时缺少健壮性处理，导致页面白屏
- 健壮性处理的方式不够优雅，出现大量臃肿的代码块

### 二、可选链操作符

&emsp;&emsp;ECMA 新的可选链操作符规范允许读取位于对象链深处的属性，而不必明确验证链中的每个引用是否有效。

```JavaScript
const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah'
  }
};

adventurer.someNonExistentMethod?.(); // undefined
adventurer.dog?.name; // undefined
```

&emsp;&emsp;可选链操作符在引用为 null 或者 undefined 的情况下不会引起错误，该表达式会**短路**返回 undefined。

```JavaScript
let potentiallyNullObj = null;
let x = 0;
let prop = potentiallyNullObj?.[x++];

console.log(x); // x 将不会被递增，依旧输出 0
```

&emsp;&emsp;例如上述代码中，x++ 表达式并不会被执行，这也算是 JavaScript 优化的一种方式。

&emsp;&emsp;可选链操作符是可以与函数结合的，但是可能会出现这种情况：

```JavaScript
const foo = {
    customMethod: () => {}
} 

foo.customMethod = 1;

foo?.customMethod?.(); // foo?.customMethod is not a function
```

&emsp;&emsp;所以在和函数结合的场景一下，一定要能够确保方法属性不会被篡改，否则还是需要用 typeof 来保证代码的健壮性。

&emsp;&emsp;在前端的开发场景下，大部分情况下都是需要将数据映射到 UI 上，直接显示一个 undefined 肯定是不合适的，所以还有一个**空值合并操作符**：

```JavaScript
let customer = {
  name: "Carl",
  details: { age: 82 }
};
let customerCity = customer?.city ?? "暗之城";
console.log(customerCity); // “暗之城”
```

> 而残酷的开发现实中，服务端可能对于没有数据的字段会直接返回 null！！！

### 三、babel 转化后的代码

&emsp;&emsp;因为可选链操作符目前处于 Stage 4，所以只能通过 Babel 或者 TypeScript 来编译该特性代码。

```JavaScript
const foo = {}
foo?.bar?.name
```

&emsp;&emsp;采用 Babel 编译上述代码，可以得到如下内容：

```JavaScript
var _foo$bar;

const foo = {};
foo === null || foo === void 0 ? void 0 : (_foo$bar = foo.bar) === null || _foo$bar === void 0 ? void 0 : _foo$bar.name;
```

&emsp;&emsp;实现的重点如下：

- **利用逻辑或运算符实现可选链运算符的短路计算特性**
- **利用临时变量完成对象链每个引用的判断**

> 可选链操作符并不会创建临时变量。

### 四、