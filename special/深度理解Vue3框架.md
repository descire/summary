https://increment.com/frontend/making-vue-3/?ref=madewithvuejs.com

Vue2.x 代码库大约是 2年半的历史，在通用软件的生命周期中，这并不是一个很长的时间，但是在这段时间里面前端缺发生了翻天覆地的变化。

● 主流浏览器中新 JavaScript 语言功能的普遍可用性
● 当前代码库随着时间的推移而暴露的设计和体系结构问题

Vue 核心的响应式对象能力 通过 Proxy 可以：

● 可以监听新属性的添加
● 良好的性能

但是由于 Proxy 在部分浏览器上无法完全 polyfill，所以必须调整框架整体的浏览器支持范围，因此只能在新的 Major 版本发布。

架构问题：

● 模板编译器的设计导致正确的映射到源代码成为一件非常具有挑战性的事情
● 支持非 DOM 平台的更高级别渲染器，会产生大量冗余代码
● 修复一些问题需要进行巨大、高风险的重构，从而也导致了社区贡献者无法自信的修改代码。


切换到 TypeScript

● 类型检查大大减少了在重构过程中引入意外错误的机会，并帮助贡献者更加自信地进行非平凡的变更。
● 对于集成环境的支持非常的丝滑，相比较 Facebook 的 Flow

使用 monorepo

● 使得框架由各个内部包组成，每个包有自己的 API、类型定义和测试
● 使得开发者更容易阅读、理解和更改所有模块，降低项目贡献壁垒和提高长期可维护性。

Composition API 是对 Option API  的一个补充。


克服虚拟 DOM 的瓶颈：

● 递归遍历两个虚拟 DOM 来比较每个节点的不同，从而确定实际 DOM 更新哪些部分，在现代 JavaScript 引擎的高级优化下，这种暴力的算法通常相当的快。
● 但是在一个包含大量静态内容和少量动态绑定的模板时，效率低下尤其明显。（仍然需要递归遍历，这是不必要的 CPU 工作）

模板编译步骤使得可以对模板执行进行静态分析，并提取动态化的部分。Vue2 中可以通过跳过静态子树在某种程度上做到这一点，但是由于过于简单的编译器体系结构，更高级的优化难以实现。在 Vue3 中使用适当的 AST 重写 编译器，可以通过转化插件的形式编写编译时优化。

减少不必要的渲染策略，需要编译时和运行时协同。

● 编译模板时生成带有优化提示的代码
● 运行时提取提示并尽可能采用快速路径

三个主要优化：

● 树级别：划分区块，从而更新块内的节点时不需要递归遍历。减少一个数量级
● 树级别：编译器会主动检测模板中的静态节点、子树甚至数据对象，并在生成代码的时候将它们提升到渲染函数之外，避免重新创建，大大提高内存使用率并减少垃圾收集的频率。
● 元素级别：编译器会根据执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。例如，具有动态类绑定和多个静态属性的元素将收到一个标志，指示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。


Vue3 CPU 占用的时间不到 Vue2 的 1/10

Tree shaing 按需使用 Vue3 中的功能。


https://www.digitalocean.com/community/tutorials/vuejs-whats-coming-in-vue-3

option API  vs composition API 

并不是取代，而是补充

大型组件中逻辑复用和可读性的问题。

● options API  代码会被拆分到各个钩子函数中，导致可读性非常差。
● mixin 方案也不能很好的解决这个问题。（为什么？）

响应式对象

Vue2 的 getter setter 实现方式 限制性多：按索引更新数组。

composition API  对 TS 支持更加友好。


包大小

优化渲染速度

编译时添加标记从而减少运行时开销，跳过不必要的条件分支，避免重新渲染。静态节点、内联函数


https://vueschool.io/articles/vuejs-tutorials/exciting-new-features-in-vue-3/

Composition API 

逻辑复用 & 代码组织方式

mixin：隐式依赖 & 命名冲突

portal 新特性


https://www.vuemastery.com/blog/vue-3-data-down-events-up/ Vue3 实践